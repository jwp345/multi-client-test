# 멀티 클라이언트 서버 테스트

## 주요 이슈

#### 계속 nio selector에 read이벤트가 발생하여 클라이언트에서 종료하였음에도 계속 데이터가 들어오는 Half-Close 문제
> 서버에서 socketChannel.read(buffer)값이 -1을 받아 클라이언트쪽에서 연결 종료 메시지를 받았을 때 key.interestOps(0); // 관심 키 제거 를 호출하여 문제 해결

#### 고아 프로세스 생성 문제
> 발견하게 된 과정 : 자식 프로세스를 생성하지 않았음에도 생성한 것처럼 부모 프로세스가 동작을 함. -> 이상하게 여겨 자식 프로세스를 따로 
런해봤더니 사용중인 포트라고 나옴 -> 자식프로세스가 고아프로세스가 되어 혼자 돌고 있는 것 발견 

#### CLOSE_WAIT과 FIN_WAIT2 상태란 무엇이고 왜 발생하는가?
> 현재 코드에선 sever.waitFor()과 같이 서버의 실행을 종료할 때까지 기다릴 경우 발생

#### 왜 스레드로 테스트할땐 selector가 스레드들을 더 할당했는데 프로세스를 나누니 1개 스레드만 사용할까?

#### 요청을 그때 그때 받아볼순 없나 논블로킹 같은 기법이면 inputstream read()의 블로킹 되는 문제를 막을 수 있지 않나?

#### server disconnected가 정확히 요청 수(10번) 만큼 호출되고 연결을 받지 않았었는데 왜 1번만 호출 되는가?
> Thread.sleep()으로 실행때처럼 텀을 넣어주니 해결됨. 
>
> 발생한 이유는 응답을 받고 서버는 클라이언트 소켓을 연결 종료시키는 시간이 필요한데, 바로 부모프로세스에서 자식프로세스를 강제 종료 시켜 FIN 패킷들이 유실된 문제로 생각됨.

#### 왜 decremnetAndGet()에선 의도대로 동작하지 않았는데 getAndDecrement()에선 의도대로 동작하는가?